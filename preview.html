<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Google Forms Clone ‚Äì UI + Drag & Drop</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">

  <!-- SortableJS -->
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.2/Sortable.min.js"></script>

  <style>
    :root{
      --purple:#2e7d32;
      /*--purple:#673ab7;*/
      --bg:#f1f3f4;
      --card:#ffffff;
      --border:#dadce0;
      --text:#202124;
    }

    body{
      margin:0;
      font-family:Roboto, Arial, sans-serif;
      background:var(--bg);
      color:var(--text);
    }

    header{
      background:var(--purple);
      height:8px;
    }

    .form-header{
      position: relative;
    }

    /* Form header total points */
    .form-header-row{
      display: flex;
      align-items: flex-start;
      gap: 16px;
    }

    .total-points{
      margin-left: auto;
      display: flex;
      align-items: center;
      gap: 8px;

      font-size: 14px;
      color: #5f6368;
      white-space: nowrap;
    }

    .total-points strong{
      font-size: 16px;
      font-weight: 500;
      color: #202124;
    }

    .container{
      max-width:820px;
      margin:24px auto;
    }

    .card{
      background:var(--card);
      border:1px solid var(--border);
      border-left: 4px solid transparent;
      border-radius:8px;
      padding:20px;
      margin-bottom:16px;
      /*position:relative;*/
    }

    .card.active{
      border-left-color: #1a73e8; /* blue active question indicator */
    }
    .title-input{
      font-size:32px;
      border:none;
      outline:none;
      width:100%;
      margin-bottom:8px;
    }

    .desc-input{
      border:none;
      outline:none;
      width:100%;
      color:#5f6368;
    }

    select{
      padding:6px;
      border:1px solid var(--border);
      border-radius:4px;
      margin-bottom:12px;
    }

    .option{
      position: relative;
      display:flex;
      align-items:center;
      gap:8px;
      margin-bottom:8px;
      user-select: none;
    }
  
    /* option multiline: textarea look like input */
    .option .opt-text{
      width: 100%;
      resize: none;
      overflow: hidden;
      line-height: 1.4;
      background: transparent;
      font-family: inherit;
      font-size: 14px;
      border: none;
      outline: none;
    }

    .option input[type=text]{
      flex:1;
      /*border:none;
      border-bottom:1px solid var(--border);*/
      outline:none;
    }

    .q-title{
      font-size:16px;
      width:100%;
      /*border:none;
      border-bottom:1px solid var(--border);*/
      outline:none;
      margin-bottom:12px;
      /* multiline */
      resize: none;
      overflow: hidden;
      line-height: 1.4;
      caret-color: transparent;
    }

    /* Show caret only when question card is active */
    .question.active .q-title,
    .q-title:focus {
      caret-color: auto;
    }

    /* Default: no visible bottom border */
    .q-title,
    .option input[type=text]{
      border: none;
      border-bottom: 1px solid transparent;
    }

    /* Show border ONLY when question card is active */
    .card.active .q-title,
    .card.active .option input[type=text]{
      border-bottom-color: var(--border);
    }

    /* Focus highlight ONLY inside active card */
    .card.active .q-title:focus,
    .card.active .option input[type=text]:focus{
      border-bottom-color: #1a73e8;
    }

    /* Default: hide borders & fade controls */
    .q-type,
    .card .btn-link{
      opacity: 0;
      pointer-events: none;
    }

    /* Active question: show controls */
    .card.active .q-type,
    .card.active .btn-link{
      opacity: 1;
      pointer-events: auto;
    }

    /* Smooth appearance */
    .q-type,
    .card .btn-link{
      transition: opacity .15s ease;
    }

    /* Remove select border when inactive */
    .q-type{
      border-color: transparent;
    }

    /* Show select border only when active */
    .card.active .q-type{
      border-color: var(--border);
    }

    /* Focus highlight */
    .card.active .q-type:focus{
      border-color: #1a73e8;
    }

    /* select points for questions */
    .question-header{
      display: flex;
      align-items: flex-start;
      gap: 12px;
    }

    .q-points{
      margin-left: auto; /* pushes points to the right */
      display: flex;
      align-items: center;
      gap: 4px;
      color: #5f6368;
      font-size: 13px;
      pointer-events: none;
    }

    .points-input{
      width: 52px;
      border: none;
      border-bottom: 1px solid transparent;
      text-align: right;
      font-size: 13px;
      color: #202124;
      outline: none;
    }

    .points-input:focus{
      border-bottom-color: #1a73e8;
    }

    .q-points span{
      font-size: 13px;
    }

    /* option drag & drop */
    .opt-drag{
      /* Hidden by default */
      opacity: 0;
      pointer-events: none;
      transition: opacity .15s ease;
      
      position: absolute;
      left: -15px;          /* adjust if needed */
      top: 50%;
      transform: translateY(-50%);

      cursor: grab;
      color: #9aa0a6;
      user-select: none;
      font-size: 18px;
      line-height: 1;
      /*margin-right: 4px;*/
    }

    /* Visible only on active question */
    .card.active .opt-drag{
      opacity: 1;
      pointer-events: auto;
    }

    .opt-icon{
      accent-color: #5f6368; /* Google Forms gray */
    }

    .btn-link{
      background:none;
      border:none;
      color:var(--purple);
      cursor:pointer;
      padding:4px 0;
    }

    .g-tooltip{
      position: relative;
    }

    .g-tooltip::after{
      content: attr(data-tooltip);
      position: absolute;
      bottom: calc(100% + 8px);
      /*bottom: 125%;*/
      left: 50%;
      transform: translateX(-50%);

      background: #3c4043;
      color: #fff;
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 4px;

      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity .15s ease;
      z-index: 1000;
    }

    .g-tooltip:hover::after,
    .g-tooltip:focus-visible::after{
      opacity: 1;
    }

    .actions{
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-top:12px;
    }

    /* Delete button */
    .actions .btn-link{
      font-size: 18px;
      color: #5f6368;
    }

    .actions .btn-link:hover{
      color: #d93025; /* Google red on delete */
    }

    .drag{
      display: none;
      justify-content: center;
      align-items: center;

      width: 100%;
      height: 24px;

      margin: -8px 0 8px 0;   /* pull it slightly up like GForms */
      cursor: grab;
      user-select: none;

      color: #9aa0a6;
      font-size: 18px;
      line-height: 4;
      pointer-events: none;
    }

    /* Required toggle */
    .required-toggle{
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: #5f6368;
      /* Hide Required toggle by default */
      pointer-events: none;
      /*transition: opacity .15s ease;*/
      visibility: hidden;
    }

    /* Show ONLY when question card is active */
    .card.active .required-toggle{
      pointer-events: auto;
      visibility: visible;
    }

    /* Switch */
    .switch{
      position: relative;
      width: 36px;
      height: 18px;
    }

    .switch input{
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider{
      position: absolute;
      cursor: pointer;
      inset: 0;
      background-color: #dadce0;
      border-radius: 18px;
      transition: 0.2s;
    }

    .slider:before{
      content: "";
      position: absolute;
      height: 14px;
      width: 14px;
      left: 2px;
      top: 2px;
      background-color: white;
      border-radius: 50%;
      transition: 0.2s;
    }

    .switch input:checked + .slider{
      background-color: var(--purple); /* your green */
    }

    .switch input:checked + .slider:before{
      transform: translateX(18px);
    }

    pre{
      background:#111;
      color:#0f0;
      padding:12px;
      font-size:12px;
      overflow:auto;
    }

    /* Bottom toolbar */
    .gforms-toolbar.bottom{
      position: fixed;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);

      display: flex;
      align-items: center;
      gap: 12px;

      background: white;
      border: 1px solid #dadce0;
      border-bottom: none;

      border-radius: 12px 12px 0 0;
      padding: 8px 12px;

      box-shadow: 0 -2px 6px rgba(0,0,0,.15);

      transition: transform .25s ease;
      z-index: 1000;
    }

    /* Hidden state */
    .gforms-toolbar.bottom.hidden{
      transform: translateX(-50%) translateY(100%);
    }

    .gforms-toolbar.collapsed{
      transform: translateX(-50%) translateY(100%);
    }

    /* Buttons row */
    .toolbar-buttons{
      display: flex;
      gap: 8px;
    }

    /* Toolbar buttons */
    .gforms-toolbar button{
      width: 40px;
      height: 40px;

      border: none;
      background: none;
      font-size: 22px;
      cursor: pointer;
      color: #5f6368;
      border-radius: 50%;
    }

    .gforms-toolbar button:hover{
      background: #f1f3f4;
    }

    /* Handle */
    .toolbar-handle{
      position: absolute;
      top: -28px;
      left: 50%;
      transform: translateX(-50%);

      width: 28px;
      height: 28px;

      border-radius: 50%;
      /*background: white;
      border: 1px solid #dadce0;*/

      display: flex;
      align-items: center;
      justify-content: center;

      font-size: 14px;
      cursor: pointer;
      color: #5f6368;

      /*box-shadow: 0 1px 3px rgba(0,0,0,.2);*/
    }

    /* Section */
    .section-label{
      font-size: 13px;
      color: #5f6368;
      margin-bottom: 8px;
    }

    /* Feedback */
    /* Feedback visibility like Google Forms */
    .feedback{
      position: relative;
      display: flex;
      align-items: flex-start;
      gap: 8px;
      margin-top: 8px;
    }

    /* Default: no underline */
    .feedback .q-title{
      border-bottom-color: transparent;
      transition: border-color .15s ease;
    }

    /* Active question: show underline */
    .card.active .feedback .q-title{
      border-bottom-color: var(--border);
    }

    /* Focus highlight */
    .card.active .feedback .q-title:focus{
      border-bottom-color: #1a73e8;
    }

    /* Proctor modal */
    .proctor-modal{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.4);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }

    .proctor-modal.hidden{
      display: none;
    }

    .proctor-card{
      background: white;
      width: 520px;
      border-radius: 12px;
      box-shadow: 0 8px 24px rgba(0,0,0,.25);
      overflow: hidden;
    }

    .proctor-header{
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
    }

    .proctor-tabs{
      display: flex;
      border-bottom: 1px solid var(--border);
    }

    .proctor-tabs .tab{
      flex: 1;
      padding: 10px;
      background: none;
      border: none;
      cursor: pointer;
      font-size: 14px;
      color: #5f6368;
    }

    .proctor-tabs .tab.active{
      color: var(--purple);
      border-bottom: 2px solid var(--purple);
      font-weight: 500;
    }

    .proctor-content{
      padding: 20px;
    }

    .tab-panel{
      display: none;
    }

    .tab-panel.active{
      display: block;
    }

    .toggle-row{
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 12px;
      font-size: 14px;
    }

    .toggle-inline{
      display:flex;
      align-items:center;
      gap:6px;
    }

    .toggle-row{
      display:flex;
      align-items:center;
      gap:8px;
    }

    .btn-icon{
      background: none;
      border: none;
      font-size: 18px;
      cursor: pointer;
    }

    /* Timer */
    .timer-row{
      display:flex;
      align-items:center;
      margin-left:4px;
      /*margin-left:auto;*/
    }

    .timer-input{
      width:42px;
      text-align:center;
      border:none;
      border-bottom:1px solid transparent;
      text-align:right;
      font-size:13px;
      color:#202124;
      outline:none;
      background:transparent;
    }

    .timer-input:focus{
      border-bottom-color:#1a73e8;
    }

    /* keep native steppers */
    .timer-input::-webkit-inner-spin-button,
    .timer-input::-webkit-outer-spin-button{
      opacity:1;
    }

    /* Top-right delete button (Google Forms style) */
    .delete-top{
      background: rgb(220, 53, 69);
      color: white;
      border: none;
      border-radius: 50%;
      width: 26px;
      height: 26px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      box-shadow: rgba(0, 0, 0, 0.15) 0px 2px 4px;
  
      position: absolute;
      top: 12px;
      right: 12px;
      opacity: 0;
      pointer-events: none;
    }

    /* Show only when question is active */
    .card.active .delete-top{
      opacity: 1;
      pointer-events: auto;
    }

    .delete-top:hover{
      color: #5f6368;
    }

    /* Camera */
    #timer {
      white-space: nowrap; /* ensures the text stays in one line */
      width: auto;         /* automatically adjusts to content */
      font-size: 15px;
      color: #b22222;
      font-weight:700;
      /*margin-right: 35px;*/
    }

    #webcam {
      position: fixed;
      /*top: 40px;*/
      right: 10px;
      border: 2px solid #333;
      width: 120px;
      height: 100px;
      overflow: hidden;
    }

    #camera {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    canvas.overlay{
      position:absolute;
      left:0;
      top:0;
      width:100%;
      height:100%;
      pointer-events:none;
    }

    video { 
      width: 100%; 
      /*border-radius:6px;*/ 
      background: #000 
    }

    .view-toggle{
      position: absolute;
      right: 16px;
      bottom: 12px;
      
      display:flex;
      align-items:center;
      gap:8px;

      font-size:13px;
      color:#5f6368;
    }

    /* Previous / Next / Submit buttons */
    .question-nav{
      position: relative;
      display: flex;
      justify-content: center; /* center Prev + Next */
      align-items: center;
      margin: 20px 0;
    }

    .nav-center{
      display: flex;
      gap: 10px;
    }

    #submitBtn{
      position: absolute;
      right: 0;

      background: var(--purple);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 18px;
      cursor: pointer;
    }

    #submitBtn:hover{
      opacity: 0.9;
    }

  </style>
</head>
<body>

<!-- Eye-Tracking -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils"></script>
<!--<script src="camera.js"></script>
<script src="eye-tracking.js"></script>
<script src="microphone.js"></script>
<link rel="stylesheet" href="eye-tracking.css">
<link rel="stylesheet" href="camera.css">-->

  <header></header>

  <!-- Webcam -->
  <div id="webcam">
    <div id="timer">Time Left: --:--</div>
    <video id="video" autoplay muted playsinline></video>
    <canvas id="overlay" class="overlay"></canvas> <!-- face detection -->
  </div>
  
  <div class="container">

    <!-- Form header -->
  <div class="card form-header">
    <div class="form-header-row">
      <div>
        <input class="title-input" id="formTitle" placeholder="Title" readonly/>
        <input class="desc-input" id="formDesc" placeholder="Form description" readonly/>
      </div>

      <div class="total-points">
        <span>Total points</span>
        <strong id="totalPoints">0</strong>
      </div>

      <div class="view-toggle">
        <span>View:</span>

        <label class="switch"> 
          <input type="checkbox" id="oneByOneToggle" onchange="toggleQuestionView(this)">
          <span class="slider"></span>
        </label>

        <span>One by one</span>
      </div>
    </div>

  </div>

    <!-- Questions -->
    <div id="questions"></div>

    <!-- Navigation Buttons -->
    <div id="questionNav" class="question-nav" style="display:none;">
      <div id="navCenter" class="nav-center">
        <button id="prevBtn" onclick="prevQuestion()">‚¨Ö Previous</button>
        <button id="nextBtn" onclick="nextQuestion()">Next ‚û°</button>
      </div>

      <button id="submitBtn" onclick="submitExam()">Submit</button>
    </div>
  </div>

  <!-- Bottom toolbar -->
  <div id="gformsToolbar" class="gforms-toolbar bottom" style="display:none">
    <!-- Handle -->
    <div class="toolbar-handle g-tooltip" id="toolbarHandle" data-tooltip="Close panel" onclick="toggleToolbar()">‚ñº</div>

    <div class="toolbar-buttons">
      <button class="g-tooltip" data-tooltip="Add question" onclick="addQuestion()">+</button>
      <button class="g-tooltip" data-tooltip="Add section" onclick="addSection()">‚â°</button>
      <button class="g-tooltip" data-tooltip="Import JSON" onclick="importJSON()">üìÇ</button>
      <button class="g-tooltip" data-tooltip="Export JSON" onclick="exportJSON()">üíæ</button>
      <button  class="g-tooltip" data-tooltip="Proctor settings" onclick="openProctorConfig()">üõ°Ô∏è</button>
      <button class="g-tooltip" data-tooltip="Home" onclick="window.location.href='index.html'">üè†</button>
    </div>
  </div>

  <!-- Proctor Modal -->
  <div id="proctorModal" class="proctor-modal hidden">
    <div class="proctor-card">

      <div class="proctor-header">
        <h3>Proctor configuration</h3>
        <button class="btn-icon" onclick="closeProctorConfig()">‚úï</button>
      </div>

      <!-- Tabs -->
      <div class="proctor-tabs">
        <button class="tab active" onclick="switchProctorTab('timer')">Timer</button>
        <button class="tab" onclick="switchProctorTab('camera')">Camera detection</button>
        <button class="tab" onclick="switchProctorTab('noise')">Noise detection</button>
        <button class="tab" onclick="switchProctorTab('screen')">Screen detection</button>
      </div>

      <!-- Tab contents -->
      <div class="proctor-content">

        <!-- TIMER -->
        <div class="tab-panel active" id="tab-timer">

          <div class="toggle-inline">
            <label class="toggle-row">
              <input type="checkbox" data-proctor="timer-enabled" onchange="toggleTimer(this)" />
              <span>Timer Left</span>
            </label>

            <div class="timer-row" style="display:none">
              <input
                type="number"
                class="timer-input"
                min="0"
                max="59"
                step="1"
                value="0"
                oninput="updateTimerJSON()"
              />
              <span>:</span>
              <input
                type="number"
                class="timer-input"
                min="0"
                max="59"
                step="1"
                value="0"
                oninput="fixSeconds(this); updateTimerJSON()"
              />
            </div>
          </div>
        </div>

        <!-- CAMERA -->
        <div class="tab-panel" id="tab-camera">
          <label class="toggle-row">
            <input type="checkbox" data-proctor="camera-enabled" />
            <span>Enable camera</span>
          </label>

          <label class="toggle-row">
            <input type="checkbox" data-proctor="camera-face" />
            <span>Detect Face absence</span>
          </label>

          <label class="toggle-row">
            <input type="checkbox" data-proctor="camera-eye" />
            <span>Eye-Tracking</span>
          </label>
        </div>

        <!-- NOISE -->
        <div class="tab-panel" id="tab-noise">
          <label class="toggle-row">
            <input type="checkbox" data-proctor="noise-enabled" />
            <span>Enable microphone</span>
          </label>

          <label class="toggle-row">
            <input type="checkbox" data-proctor="noise-loud" />
            <span>Noise-detection: Detect loud background noise</span>
          </label>
        </div>

        <!-- SCREEN -->
        <div class="tab-panel" id="tab-screen">
          <label class="toggle-row">
            <input type="checkbox" data-proctor="screen-tab"/>
            <span>Detect tab switching</span>
          </label>

          <label class="toggle-row">
            <input type="checkbox" data-proctor="screen-fullscreen"/>
            <span>Detect fullscreen exit</span>
          </label>
        </div>

      </div>

    </div>
  </div>
</div>

<script>

// question must have its own radio group name
let questionIdCounter = 0; // question ID

const questionsEl = document.getElementById('questions');

function readFileAsJSON(file){
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
      try {
        resolve(JSON.parse(reader.result));
      } catch(e){
        reject(new Error("Invalid JSON file"));
      }
    };
    reader.onerror = () => reject(new Error("File read error"));
    reader.readAsText(file);
  });
}

/***************************
Auto-grade: Exam results
***************************/
let examData = null;

// Auto-grade function (JSON-based, correct)
function gradeExamFromJSON(){
  let score = 0;
  let total = examData.questions.length;
  let details = [];

  examData.questions.forEach((q, index) => {
    const questionEl = document.querySelectorAll('.question')[index];
    debugger;
    // Correct answers from JSON
    const correctOptions = q.options
      .map((opt, i) => opt.checked ? i : null)
      .filter(i => i !== null);

    // User selected answers from UI
    const selectedOptions = [...questionEl.querySelectorAll('input:checked')]
      .map(input => Number(input.dataset.optionIndex));

    // Compare arrays (order-independent)
    const isCorrect =
      correctOptions.length === selectedOptions.length &&
      correctOptions.every(i => selectedOptions.includes(i));

    if (isCorrect) score++;

    details.push({
      question: q.text,
      correctOptions,
      selectedOptions,
      isCorrect,
      feedback: q.comment || ""
    });
  });

  return {
    title: examData.title,
    score,
    total,
    percentage: Math.round((score / total) * 100),
    details
  };
}

/***************************
Header
***************************/
// Add total points calculation
function updateTotalPoints(){
  let total = 0;

  document.querySelectorAll('.points-input').forEach(input => {
    const val = parseFloat(input.value);
    if (!isNaN(val)) total += val;
  });

  document.getElementById('totalPoints').textContent =
    total % 1 === 0 ? total : total.toFixed(2);
}

/***************************
Questions
***************************/
document.addEventListener('input', e => {
  // Add question multiline
  if(e.target.classList.contains('q-title')||
    e.target.classList.contains('opt-text')){
    e.target.style.height = 'auto';
    e.target.style.height = e.target.scrollHeight + 'px';
  }

  updateJSON();
});

// Toggleable radios
document.addEventListener('click', e => {
  const radio = e.target;

  if (!radio.classList.contains('opt-icon')) return;

  if (radio.type !== 'radio') return;

  // if it was already checked, uncheck it
  if (radio.dataset.wasChecked === 'true') {
    radio.checked = false;
    radio.dataset.wasChecked = 'false';
  } else {
    // uncheck other radios in same group
    document
      .querySelectorAll(`input[type="radio"][name="${radio.name}"]`)
      .forEach(r => r.dataset.wasChecked = 'false');

    radio.dataset.wasChecked = 'true';
  }

  updateJSON();
});

function addQuestion(){
  const q = document.createElement('div');
  q.className = 'card question';
  q.dataset.qid = 'q_' + (++questionIdCounter); // ID question

  q.innerHTML = `
    <div class="drag">: : :</div>

    <div class="question-header">

      <button class="btn-link g-tooltip delete-top"
        data-tooltip="Delete question"
        onclick="removeQuestion(this)">
      <i class="fa fa-trash"></i></button>

      <!--
      <button class="btn-link g-tooltip delete-top"
        data-tooltip="Delete question"
        onclick="removeQuestion(this)">
        üóëÔ∏è
      </button>-->
      
      <div class="q-points">
        <input type="number"
          class="points-input"
          min="0"
          step="0.01"
          placeholder="0"
          oninput="limitDecimals(this); updateJSON()" />
        <span>points</span>
      </div>
    </div>

    <textarea class="q-title" placeholder="Question" rows="1" readonly></textarea>

    <select class="q-type" onchange="updateOptions(this)">
      <option value="radio">‚óâ One choice</option>
      <option value="checkbox">‚òë Multiple choices</option>
    </select>

    <div class="options"></div>

    <div>
      <button class="btn-link" onclick="addOption(this)">Add option</button>
    </div>

    <div class="feedback" style="display:none">
      <textarea class="q-title q-comment" id="comment" rows="1"
        placeholder="Feedback"></textarea>
    </div>

    <div class="actions">
      <!--
      <button class="btn-link g-tooltip"
        data-tooltip="Duplicate"
        onclick="duplicateQuestion(this)">
        üìÑ
      </button>-->

      <div class="required-toggle">
        <span>Required</span>
        <label class="switch">
          <input type="checkbox" class="q-required" onchange="updateJSON()">
          <span class="slider"></span>
        </label>
      </div>
    </div>
  `;

  questionsEl.appendChild(q);
  addOption(q.querySelector('.btn-link'));
  enableOptionDrag(q); // drag & drop per option
  updateJSON();
}

function duplicateQuestion(btn){
  const q = btn.closest('.question');
  const clone = q.cloneNode(true);

  // new question ID (important for radio groups)
  clone.dataset.qid = 'q_' + (++questionIdCounter);

  // fix radio group names
  clone.querySelectorAll('.opt-icon[type="radio"]').forEach(radio => {
    radio.name = clone.dataset.qid;
  });

  // remove active styles
  clone.classList.remove('active');

  // insert after original
  q.after(clone);

  // re-enable drag & drop for options
  enableOptionDrag(clone);

  updateJSON();
}

function removeQuestion(btn){
  btn.closest('.question').remove();
  updateJSON();
  updateSectionNumbers();
}

// points: enforce max 2 decimals
function limitDecimals(input){
  const value = input.value;
  if (!value.includes('.')) return;

  const [int, dec] = value.split('.');
  if (dec.length > 2){
    input.value = `${int}.${dec.slice(0,2)}`;
  }
}
 
function addOption(btn){
  const q = btn.closest('.question');
  const type = q.querySelector('.q-type').value;
  const options = q.querySelector('.options');
  const qid = q.dataset.qid; // ID question

  const opt = document.createElement('div');
  opt.className = 'option';

  opt.innerHTML = `
    <div class="opt-drag">‚ãÆ‚ãÆ</div>
    <input class="opt-icon" type="${type}" ${type === 'radio' ? `name="${qid}" data-was-checked="false"` : ''} />
    <textarea class="opt-text" rows="1"></textarea>
    <button class="btn-link g-tooltip" data-tooltip="Remove"
      onclick="this.parentElement.remove(); updateJSON()">‚úï</button>
  `;
    // assign name to radio inputs when adding options

  const optionNumber = getNextOptionNumber(q);
  opt.querySelector('.opt-text').placeholder = `Option ${optionNumber}`; // option dynamic placeholder numbering

  options.appendChild(opt);

  // to map UI answers
  const optionIndex = options.querySelectorAll('.option').length - 1;
  opt.querySelector('.opt-icon').dataset.optionIndex = optionIndex;
    /* resulting HTML:
    <input type="radio" data-option-index="0">
    <input type="radio" data-option-index="1">
    */
  //

  enableOptionDrag(opt); // drag & drop per option

  updateJSON();
}

function updateOptions(select){
  const q = select.closest('.question');
  const type = select.value;
  const qid = q.dataset.qid; // ID question

  q.querySelectorAll('.opt-icon').forEach(icon => {
    icon.type = type;     // radio or checkbox
    icon.checked = false;

    if(type === 'radio'){
      icon.name = qid;
      icon.dataset.wasChecked = 'false'; // toggleable radios
    } else {
      icon.removeAttribute('name');
      delete icon.dataset.wasChecked; // toggleable radios
    }
  });

  updateJSON();
}

// Track option count per question
function getNextOptionNumber(q){
  return q.querySelectorAll('.opt-text').length + 1;
}

// enable drag & drop per options
function enableOptionDrag(q){
  const options = q.querySelector('.options');

  if(!options || options._sortable)
    return;

  // drag starts only from .opt-drag
  options._sortable = new Sortable(options, {
    handle: '.opt-drag',
    animation: 150,
    filter: '.opt-icon, .opt-text, button',
    preventOnFilter: false,
    onEnd: updateJSON
  });
}

// auto-resize textareas when import JSON file
function autoResizeTextarea(el){
  if (!el) return;
  el.style.height = 'auto';
  el.style.height = el.scrollHeight + 'px';
}

/***************************
Navigation Buttons Next / Previous / Submit
***************************/
let oneByOneMode = false;
let currentQuestionIndex = 0;

function toggleQuestionView(toggle){
  oneByOneMode = toggle.checked;
  currentQuestionIndex = 0;

  if(oneByOneMode){
    showOnlyQuestion(currentQuestionIndex);
    document.getElementById('navCenter').style.display = 'block';
    document.getElementById('questionNav').style.display = 'block';
    updateNavButtons();
  }else{
    showAllQuestions();
    document.getElementById('navCenter').style.display = 'none';
    document.getElementById('questionNav').style.display = 'block';
  }

  updateSubmitVisibility();
}

function showOnlyQuestion(index){
  const questions = document.querySelectorAll('.question');

  questions.forEach((q, i) => {
    q.style.display = i === index ? 'block' : 'none';
    //q.classList.toggle('active', i === index);
  });
}

function showAllQuestions(){
  document.querySelectorAll('.question').forEach(q => {
    q.style.display = '';
    //q.classList.remove('active');
  });

  updateSubmitVisibility();
}

function nextQuestion(){
  const questions = document.querySelectorAll('.question');

  if(currentQuestionIndex < questions.length - 1){
    currentQuestionIndex++;
    showOnlyQuestion(currentQuestionIndex);
    updateNavButtons();
  }
}

function prevQuestion(){
  if(currentQuestionIndex > 0){
    currentQuestionIndex--;
    showOnlyQuestion(currentQuestionIndex);
    updateNavButtons();
  }
}

// control button states
function updateNavButtons() {
  const questions = document.querySelectorAll('.question');
  const prevBtn = document.getElementById('prevBtn');
  const nextBtn = document.getElementById('nextBtn');
  const submitBtn = document.getElementById('submitBtn');

  // Disable Previous on first question
  prevBtn.disabled = currentQuestionIndex === 0;

  // Disable Next on last question
  nextBtn.disabled = currentQuestionIndex === questions.length - 1;

  // Show Submit ONLY on last question
  submitBtn.style.display = currentQuestionIndex === questions.length - 1 ? 'inline-block' : 'none';
}

function updateSubmitVisibility() {
  const submitBtn = document.getElementById('submitBtn');
  const questions = document.querySelectorAll('.question');

  if (!oneByOneMode) {
    // Show-all mode ‚Üí always show Submit
    submitBtn.style.display = 'inline-block';

    document.getElementById('navCenter').style.display = 'none';
    document.getElementById('questionNav').style.display = 'block';

    return;
  }

  // One-by-one mode ‚Üí only on last question
  submitBtn.style.display =
    currentQuestionIndex === questions.length - 1
      ? 'inline-block'
      : 'none';
}

// submit exam
// Protect manual Submit (no double submit)
let examSubmitted = false;

function submitExam(){
  if (examSubmitted) return;
  
  examSubmitted = true;

  clearInterval(timerInterval);

  // üëâ collect answers here
  console.log("Exam submitted");
  alert("Exam submitted!");

  // collect answers here
  // redirect / show results / save to Firebase
  const result = gradeExamFromJSON();
  debugger;
  localStorage.setItem("examResult", JSON.stringify(result));

  window.location.href = "result.html";
}

// Auto-submit when the timer ends
// Auto-submits when time = 0
// Prevents double submit
function autoSubmitExam(){
  if (examSubmitted) return;

  examSubmitted = true;
  alert("‚è± Time is up! Exam submitted automatically.");

  submitExam(); // üëà your existing submit logic
}

/***************************
Proctor configuration
***************************/
function openProctorConfig(){
  document.getElementById('proctorModal').classList.remove('hidden');
}

function closeProctorConfig(){
  document.getElementById('proctorModal').classList.add('hidden');
}

function switchProctorTab(name){
  document.querySelectorAll('.proctor-tabs .tab')
    .forEach(t => t.classList.remove('active'));

  document.querySelectorAll('.tab-panel')
    .forEach(p => p.classList.remove('active'));

  document.querySelector(`[onclick="switchProctorTab('${name}')"]`)
    .classList.add('active');

  document.getElementById(`tab-${name}`)
    .classList.add('active');
}

// Timer
function toggleTimer(cb){
  const row = cb.closest('.tab-panel').querySelector('.timer-row');
  row.style.display = cb.checked ? 'flex' : 'none';
}

function fixSeconds(input){
  if (input.value > 59) input.value = 59;
  if (input.value < 0) input.value = 0;
}

function updateTimerJSON(){
  const panel = document.getElementById('tab-timer');
  const min = panel.querySelector('.timer-min')?.value || 0;
  const sec = panel.querySelector('.timer-sec')?.value || 0;

  const totalSeconds = (Number(min) * 60) + Number(sec);

  // save where you want (example)
  console.log('Timer (seconds):', totalSeconds);
}

/***************************
Save in JSON for database
***************************/
function updateJSON(){
  const form = {
    title: formTitle.value,
    description: formDesc.value,
    questions: []
  };

  document.querySelectorAll('.question').forEach(q => {

    // points in JSON
    const pointsInput = q.querySelector('.points-input');
    const points = parseFloat(pointsInput?.value) || 0;

    // build JSON
    form.questions.push({
      text: q.querySelector('.q-title').value,
      type: q.querySelector('.q-type').value,
      points: points,
      required: q.querySelector('.q-required')?.checked || false,
      options: [...q.querySelectorAll('.option')].map(opt => {
        const textInput = opt.querySelector('.opt-text');
        const control = opt.querySelector('.opt-icon');

        return {
          text: textInput.value || textInput.placeholder,
          checked: control.checked
        };
      }),
      comment: q.querySelector('.q-comment')?.value || ''
    });
  });

  form.proctor = getProctorSettings();

  updateTotalPoints();
}

function isChecked(key){
  return document.querySelector(`[data-proctor="${key}"]`)?.checked || false;
}

function getProctorSettings(){
  const timerEnabled = isChecked('timer-enabled');

  const timerInputs = document.querySelectorAll('#tab-timer .timer-input');

  return {
    timer: {
      enabled: timerEnabled,
      minutes: timerEnabled ? Number(timerInputs[0]?.value || 0) : 0,
      seconds: timerEnabled ? Number(timerInputs[1]?.value || 0) : 0
    },
    camera: {
      enabled: isChecked('camera-enabled'),
      faceAbsence: isChecked('camera-face'),
      eyeTracking: isChecked('camera-eye')
    },
    noise: {
      enabled: isChecked('noise-enabled'),
      loudNoise: isChecked('noise-loud')
    },
    screen: {
      tabSwitch: isChecked('screen-tab'),
      fullscreenExit: isChecked('screen-fullscreen')
    }
  };
}

// import exam: load JSON into editor
function loadFormFromJSON(data){

  // clear existing
  questionsEl.innerHTML = '';
  questionIdCounter = 0;

  // header
  formTitle.value = data.title || '';
  formDesc.value = data.description || '';

  // questions
  data.questions?.forEach(qData => {
    addQuestion();

    const q = questionsEl.lastElementChild;

    // auto-resize for question
    const qTitle = q.querySelector('.q-title');
    qTitle.value = qData.text || '';
    autoResizeTextarea(qTitle);

    q.querySelector('.q-type').value = qData.type || 'radio';
    q.querySelector('.points-input').value = qData.points ?? 0;
    updateOptions(q.querySelector('.q-type'));

    // remove default option
    q.querySelector('.options').innerHTML = '';

    qData.options?.forEach(opt => {
      addOption(q.querySelector('.btn-link'));
      const lastOpt = q.querySelector('.options').lastElementChild;

      // auto-resize for options
      const optText = lastOpt.querySelector('.opt-text');
      optText.value = opt.text || '';
      lastOpt.querySelector('.opt-icon').checked = false; // option unchecked
      autoResizeTextarea(optText);

      // to map UI answers
      lastOpt.querySelector('.opt-icon').checked = !!opt.checked;
        /* resulting HTML:
        <input type="radio" data-option-index="0">
        <input type="radio" data-option-index="1">
        */
      //
    });

    // feedback
    if(qData.comment){
      // auto-resize for feedback
      const comment = q.querySelector('#comment');
      comment.value = qData.comment;
      autoResizeTextarea(comment);
    }
  });

  // reset view mode after loading
  document.getElementById('oneByOneToggle').checked = false;
  oneByOneMode = false;
  showAllQuestions();
  //document.getElementById('questionNav').style.display = 'none';

  // Auto-resize ALL on load
  //q.querySelectorAll('textarea').forEach(autoResizeTextarea);
  
  updateJSON();
}

/***************************
Bottom toolbar
***************************/
function toggleToolbar(){
  const toolbar = document.querySelector('.gforms-toolbar');
  const handle = document.getElementById('toolbarHandle');

  toolbar.classList.toggle('collapsed');

  const isCollapsed = toolbar.classList.contains('collapsed');

  handle.textContent = isCollapsed ? '‚ñ≤' : '‚ñº';
  handle.setAttribute(
    'data-tooltip',
    isCollapsed ? 'Open panel' : 'Close panel'
  );
}

/***************************
Section
***************************/
function addSection(){
  const section = document.createElement('div');
  section.className = 'card';
  section.innerHTML = `
    <div class="section-label"></div>
    <input class="title-input" placeholder="Section title" />
    <input class="desc-input" placeholder="Section description" />
  `;
  questionsEl.appendChild(section);
  updateJSON();
  updateSectionNumbers();
}

// auto numbering
function updateSectionNumbers(){
  const sections = document.querySelectorAll('.section-label');
  sections.forEach((s, i) => {
    s.textContent = `Section ${i + 1} of ${sections.length}`;
  });
}

/***************************
Timer
***************************/
let timeLeft = 60 * 60;   // default: 15 minutes, change before start
let timerInterval = null;

function startTimer(){
  // you can set timeLeft before startingExam if desired
  updateTimerDisplay();

  timerInterval = setInterval(() => {
    timeLeft--;

    updateTimerDisplay();

    if(timeLeft <= 0){
      clearInterval(timerInterval);
      autoSubmitExam();
    }
  }, 1000);
}

function updateTimerDisplay(){
  const minutes = Math.max(0, Math.floor(timeLeft / 60));
  const seconds = Math.max(0, timeLeft % 60);
  document.getElementById('timer').textContent = `Time Left: ${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
}

/***************************
Camera
***************************/
let stream = null;
let mediaRecorder = null;
let recordedChunks = [];
let snapshotTimer = null;
let isCameraStarted = false;

const video = document.getElementById('video');
const toggleRecordingBtn = document.getElementById('toggleRecording');
const downloadRecordingBtn = document.getElementById('downloadRecording');

async function startCamera(){
  if(stream) return; // already started

  try {
    // Eye-Tracking
    const faceMesh = new window.FaceMesh({
      locateFile: (file) =>
        `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`,
    });

    faceMesh.setOptions({
      maxNumFaces: 1,
      refineLandmarks: true, // IMPORTANT ‚Üí gives iris landmarks (468-478)
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5,
    });

    faceMesh.onResults(onResults);

    // Start camera
    const cam = new window.Camera(video, {
      onFrame: async () => {
        await faceMesh.send({ image: video });
      },
      width: 480,
      height: 360,
    });
    cam.start();

    // set canvas size to video display size
    document.getElementById("overlay").style.display = "none"; // hide detection rectangle, hide = "none", show = "block"

    overlay.width = video.videoWidth || video.clientWidth;
    overlay.height = video.videoHeight || video.clientHeight;

    console.log('Camera started');

    //-------------------------------------//
    
    // Face detection
    // lazy-load TF and model after camera starts
    await loadModelIfNeeded();
    startDetectLoop();

    isCameraStarted = true;

  } catch(e) {
    console.log('Camera error', e);
    alert('Camera error', e);
  }

  function stopCamera(){
    if (stream){
      stream.getTracks().forEach(t => t.stop());
      stream = null;
    }
    video.pause();
    video.srcObject = null;
    stopDetectLoop();
    console.log('Camera stopped');
    ctx && ctx.clearRect(0,0,overlay.width, overlay.height);
}
}

/***************************
Face detection
***************************/
let model = null;
let detectLoopId = null;
let overlay = document.getElementById('overlay');
let ctx = overlay.getContext('2d');
let lastFaceState = 'unknown'; // 'no_face'|'one_face'|'multi'

// Detection loop
let lastDetectTime = 0;
async function detectOnce(){
  if (!model || !video || video.readyState < 2) return;

  const now = performance.now();

  // throttle to ~700ms
  if (now - lastDetectTime < 600) return;
  lastDetectTime = now;
  const returnTensors = false;
  const predictions = await model.estimateFaces(video, returnTensors);

  // predictions is array of face objects with topLeft, bottomRight, probability
  ctx.clearRect(0,0,overlay.width, overlay.height);
  let state = 'no_face';

  //console.log('predictions.length = ', predictions.length);
  
  if (!predictions || predictions.length === 0) {
    state = 'no_face';
  } else if (predictions.length === 1) {
    state = 'one_face';

    // draw box
    const p = predictions[0];
    const [x1,y1] = p.topLeft;
    const [x2,y2] = p.bottomRight;
    const w = x2-x1, h = y2-y1;
    ctx.strokeStyle = 'rgba(6,182,212,0.9)';
    ctx.lineWidth = 3;
    ctx.strokeRect(x1, y1, w, h);
    // label
    ctx.fillStyle = 'rgba(6,182,212,0.1)';
    ctx.fillRect(x1, y1-24, 120, 20);
    ctx.fillStyle = '#042028';
    ctx.font = '14px sans-serif';
    ctx.fillText('face detected', x1+6, y1-9);
  } else {
    state = 'multi';
    // draw multi boxes
    predictions.forEach(p => {
      const [x1,y1] = p.topLeft;
      const [x2,y2] = p.bottomRight;
      const w = x2-x1, h = y2-y1;
      ctx.strokeStyle = 'rgba(255,110,96,0.95)';
      ctx.lineWidth = 3;
      ctx.strokeRect(x1, y1, w, h);
    });
    ctx.fillStyle = 'rgba(255,110,96,0.12)';
    ctx.fillRect(8, 8, 220, 26);
    ctx.fillStyle = '#3a0f07';
    ctx.font = '14px sans-serif';
    ctx.fillText('Multiple faces detected ‚Äî please have only one person', 14, 25);
  }

  // state transitions
  if (state !== lastFaceState) {
    // log event
    if (state === 'no_face') {
      alert('No face detected. Please stay in view of the camera.');
      console.log('No face detected. Please stay in view of the camera.');
    } else if (state === 'multi') {
      alert('Multiple faces detected. Only one person should take the exam.');
      console.log('Multiple faces detected. Only one person should take the exam.');
    } else if (state === 'one_face') {
      //alert('Single face detected');
      console.log('Single face detected');
    }
    lastFaceState = state;
  }
}

function startDetectLoop(){
  if (detectLoopId) return;
  detectLoopId = setInterval(() => {
    detectOnce().catch(e => console.error('detect error', e));
  }, 700);
  console.log('Detection started');
}

function stopDetectLoop(){
  if (detectLoopId) {
    clearInterval(detectLoopId);
    detectLoopId = null;
  }
  console.log('Detection stopped');
}

function loadScript(src){
  return new Promise((resolve, reject) => {
    const s = document.createElement('script');
    s.src = src;
    s.onload = () => resolve();
    s.onerror = e => reject(e);
    document.head.appendChild(s);
  });
}

// Load TF.js and BlazeFace if needed
async function loadModelIfNeeded(){
  if (model) return;

  console.log('Loading model (may take a few seconds)...');

  // load TF.js
  if (!window.tf) {
    await loadScript('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.20.0/dist/tf.min.js');
  }
  if (!window.blazeface) {
    await loadScript('https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface@0.0.7/dist/blazeface.min.js');
  }
  // load model
  model = await blazeface.load();
  console.log('Model loaded');
}

/***************************
Eye-Tracking
***************************/
const canvas = document.getElementById("overlay");

let lastBlinkTime = 0;
let blinkCount = 0;

function distance(a, b) {
  return Math.hypot(a.x - b.x, a.y - b.y);
}

function getEyeOpenness(landmarks, top, bottom) {
  return distance(landmarks[top], landmarks[bottom]);
}

function analyzeEyes(landmarks) {
  // MediaPipe eye landmark indices
  const LEFT_TOP = 159;
  const LEFT_BOTTOM = 145;
  const RIGHT_TOP = 386;
  const RIGHT_BOTTOM = 374;

  const leftOpenness = getEyeOpenness(landmarks, LEFT_TOP, LEFT_BOTTOM);
  const rightOpenness = getEyeOpenness(landmarks, RIGHT_TOP, RIGHT_BOTTOM);

  const avgOpenness = (leftOpenness + rightOpenness) / 2;

  if (avgOpenness < 0.01) {
    const now = Date.now();
    if (now - lastBlinkTime > 300) {
      blinkCount++;
      lastBlinkTime = now;
    }

    //alert('NO BLINK');
    return "BLINK";
  }

  return "OPEN";
}

function getGazeDirection(landmarks) {
  // Eye corner indices
  const leftEyeLeft = landmarks[33];
  const leftEyeRight = landmarks[133];
  const leftPupil = landmarks[468]; // iris center

  const eyeWidth = distance(leftEyeLeft, leftEyeRight);
  const pupilOffset = (leftPupil.x - leftEyeLeft.x) / eyeWidth;

  if (pupilOffset < 0.32) {
    alert('NO LOOK TO THE RIGHT');
    return "LOOKING RIGHT";
  }

  if (pupilOffset > 0.68) {
    alert('NO LOOK TO THE LEFT');
    return "LOOKING LEFT";
  }

  return "CENTER";
}

function onResults(results) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

  if (!results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0) {
    ctx.fillStyle = "red";
    ctx.fillText("FACE NOT DETECTED", 10, 20);
    return;
  }

  const landmarks = results.multiFaceLandmarks[0];

  // Draw mesh
  window.drawConnectors(ctx, landmarks, window.FACEMESH_TESSELATION, { color: "#0f0" });

  // Eye state
  const eyeState = analyzeEyes(landmarks);
  const gaze = getGazeDirection(landmarks);

  ctx.fillStyle = "yellow";
 /*
  console.log('Eyes: ', eyeState);
  console.log('Gaze: ', gaze);
  console.log('Blink Count: ', blinkCount);
  */
}

/***************************
Microphone
***************************/
// Config
const NOISE_THRESHOLD = 0.16;   // When ‚Äútoo loud‚Äù
const SPEAK_THRESHOLD = 0.18;   // When voice detected
const MAX_NOISE_TIME = 5;       // Seconds before auto-fail

let noiseSeconds = 0;
let lastNoiseTime = 0;
let failed = false;

async function startMicrophone() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const analyser = audioCtx.createAnalyser();
        analyser.fftSize = 2048;

        const freqAnalyser = audioCtx.createAnalyser();
        freqAnalyser.fftSize = 512;

        const mic = audioCtx.createMediaStreamSource(stream);
        mic.connect(analyser);
        mic.connect(freqAnalyser);

        const timeData = new Uint8Array(analyser.fftSize);
        const freqData = new Uint8Array(freqAnalyser.frequencyBinCount);

        function update() {
            analyser.getByteTimeDomainData(timeData);
            freqAnalyser.getByteFrequencyData(freqData);

            // Calculate volume (RMS)
            let sum = 0;
            for (let i = 0; i < timeData.length; i++) {
                const v = (timeData[i] - 128) / 128;
                sum += (v * v);
            }
            const volume = Math.sqrt(sum / timeData.length);

            //console.log('volume = ', volume);

            // Check for noise / speaking
            if (volume > SPEAK_THRESHOLD) {
                console.log('üé§ Someone is speaking!');
                alert('üé§ Someone is speaking!');
                lastNoiseTime = Date.now();
            } else if (volume > NOISE_THRESHOLD) {
                console.log('‚ö† Too loud!');
                alert('‚ö† Too loud!');
                lastNoiseTime = Date.now();
            } else {
                //alertBox.textContent = "";
            }

            // Count continuous noise time
            if (Date.now() - lastNoiseTime < 1000)
              noiseSeconds++;
            else
              noiseSeconds = 0;

            //console.log('noiseSeconds = ', noiseSeconds);

            // Auto-fail
            if (!failed && noiseSeconds >= MAX_NOISE_TIME) {
                failed = true;
                alert("‚ùå Exam failed: too much noise.");
            }

            requestAnimationFrame(update);
        }

        update();

    } catch (e) {
        alert("Microphone error: " + e.message);
    }
}

/***************************
Screen-switch-detection
***************************/
let violations = 0;
const MAX_VIOLATIONS = 10;

function log(msg) {
    const t = new Date().toLocaleTimeString();
    logBox.textContent += `[${t}] ${msg}\n`;
}

function addViolation(reason) {
    violations++;
    alert(`‚ùå Violation #${violations}: ${reason}`);
    //log(`‚ùå Violation #${violations}: ${reason}`);

    if (violations >= MAX_VIOLATIONS) {
        alert("‚ùå Exam failed. Too many violations.");
        // End exam
    }
}

function screenSwitchdetection() {

// Block Keyboard Shortcuts (as many as possible)
document.addEventListener("keydown", (e) => {
    const blockedCombos = [
        e.ctrlKey && e.key === "t",
        e.ctrlKey && e.key === "w",
        e.ctrlKey && e.key === "n",
        e.ctrlKey && e.key === "r",
        e.key === "F11",
        e.key === "F5",
        e.key === "Escape",
        //e.key === "F12", // Devtools
    ];

    if (blockedCombos.some(Boolean)) {
        e.preventDefault();
        addViolation(`Blocked shortcut: ${e.key}`);
    }
});

//---------------------------//

// Detect DevTools Opening (3 methods combined)
// Method A ‚Äî Size check
/*
setInterval(() => {
  if(isCameraStarted) {
    const threshold = 160;
    if (window.outerWidth - window.innerWidth > threshold ||
        window.outerHeight - window.innerHeight > threshold) {
        addViolation("DevTools detected (resize)");
    }
  }
}, 1000);
*/
// Method B ‚Äî Debugger trap
let check = false;
setInterval(() => {
  if(isCameraStarted) {
    const start = Date.now();
    if (Date.now() - start > 10) {
        addViolation("DevTools detected (debugger slowdown)");
    }
  }
}, 2000);

// Method C ‚Äî Console open check
console.log("%cSTOP", "font-size: 100px; color: red;");

//---------------------------//

// Screen-switch detection (tab change + blur/focus)
document.addEventListener("visibilitychange", () => {
    if (document.hidden) addViolation("Tab switch or minimize");
});
/*
window.addEventListener("blur", () => {
    addViolation("Window lost focus (possible Alt+Tab)");
});
*/

//---------------------------//

// Detect leaving fullscreen
document.addEventListener("fullscreenchange", () => {
    if (!document.fullscreenElement) addViolation("Exited fullscreen");
});
}
//---------------------------//

// Fake ‚ÄúSecond Monitor Detection‚Äù (best possible)
let originalWidth = window.screen.width;

setInterval(() => {
  if(isCameraStarted) {
    if (window.screen.width !== originalWidth) {
        addViolation("Possible second monitor usage");
    }
  }
}, 3000);

/***************************
Initialization
***************************/
//async function handleImport(){
window.onload = async function() {

  try {
    // Read JSON file (awaitable)
    const json = localStorage.getItem("formContent");
    examData = JSON.parse(json);

    // ask for webcam
    //await startCamera();

    try {
      // start Microphone
      //await startMicrophone();
    } catch (micErr) {
      console.warn("Microphone error:", micErr);
      alert("‚ö† Microphone access denied. Noise monitoring disabled.");
    }
    
    // Load questions
    loadFormFromJSON(examData);
    //addQuestion();
    startTimer();

    //screenSwitchdetection();

  } catch(err) {
    alert('‚ùå Camera error or permission denied: ' + err.message);
  };
}

new Sortable(questionsEl, {
  handle: '.drag',
  animation: 150,
  onEnd: updateJSON
});

</script>

</body>
</html>